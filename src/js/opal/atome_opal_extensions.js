Opal.modules["extensions/object"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $thrower = Opal.thrower, $def = Opal.def, self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil;

  Opal.add_stubs('eval');
  return $def(self, '$alert', function $$alert(val) {try { 
    
    return $$('JS').$eval("alert('" + (val) + "')")} catch($e) {
      if ($e === Opal.t_eval_return) return $e.$v;
      throw $e;
    }
  })
};

Opal.modules["extensions/js"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $defs = Opal.defs, $thrower = Opal.thrower, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('gsub,Native,eval');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'JS');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $defs(self, '$eval', function $JS_eval$1(string) {
      var self = this, clean_str = nil, result = nil;

      
      clean_str = string.$gsub("return", "");
      result = eval(clean_str);
      return self.$Native(result);
    });
    return $defs(self, '$global', function $$global() {try { 
      
      return $$('JS').$eval("window")} catch($e) {
        if ($e === Opal.t_eval_return) return $e.$v;
        throw $e;
      }
    });
  })($nesting[0], $nesting)
};

Opal.modules["extensions/geolocation"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $klass = Opal.klass, $send = Opal.send, $gvars = Opal.gvars, $def = Opal.def, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('rescue,then,geolocate,navigator,[]=,latitude,coords,longitude,p');
  return (function($base, $super) {
    var self = $klass($base, $super, 'Atome');

    
    return $def(self, '$geolocation', function $$geolocation() {
      var self = this, localisation = nil;
      if ($gvars.window == null) $gvars.window = nil;

      
      localisation = (new Map([["latitude", nil], ["longitude", nil]]));
      return $send($send($gvars.window.$navigator().$geolocate(), 'then', [], function $$1(pos){var $a;

        
        if (pos == null) pos = nil;
        localisation['$[]=']("latitude", pos.$coords().$latitude());
        return ($a = ["longitude", pos.$coords().$longitude()], $send(localisation, '[]=', $a), $a[$a.length - 1]);}), 'rescue', [], function $$2(err){var self = $$2.$$s == null ? this : $$2.$$s;

        
        if (err == null) err = nil;
        self.$p(err);
        return (localisation = nil);}, {$$s: self});
    })
  })($nesting[0], null)
};

Opal.modules["extensions/ping"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $klass = Opal.klass, $truthy = Opal.truthy, $thrower = Opal.thrower, $def = Opal.def, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('is_a?,instance_exec,address,eval');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Atome');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$ping', function $$ping(my_proc) {try { 
      var self = this, js_code = nil;

      
      if (my_proc == null) my_proc = false;
      if ($truthy(my_proc['$is_a?']($$('Proc')))) {
        self.$instance_exec(my_proc)
      };
      js_code = "var p = new Ping();\n" + "p.ping('https://' + \"" + (self.$address()) + "\" + '', function (err, data) {\n" + "    if (err) {\n" + "       return false;\n" + "    } else {\n" + "       console.log(\"the site \" + \"" + (self.$address()) + "\" + \" is up!\");\n" + "    }\n" + "});\n";
      return $$('JS').$eval(js_code);} catch($e) {
        if ($e === Opal.t_eval_return) return $e.$v;
        throw $e;
      }
    }, -1)
  })($nesting[0], null, $nesting)
};

Opal.modules["extensions/sha"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $klass = Opal.klass, $truthy = Opal.truthy, $eqeq = Opal.eqeq, $thrower = Opal.thrower, $def = Opal.def, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('==,downcase,eval,hexdigest');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Atome');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$calculate_sha', function $$calculate_sha(string) {try { 
      var js_code = nil;

      if (($eqeq($$('RUBY_ENGINE').$downcase(), "opal") || ($truthy("wasm32-wasi")))) {
        
        js_code = "sha256('" + (string) + "')";
        return $$('JS').$eval(js_code);
      } else {
        return $$$($$('Digest'), 'SHA256').$hexdigest(string)
      }} catch($e) {
        if ($e === Opal.t_eval_return) return $e.$v;
        throw $e;
      }
    })
  })($nesting[0], null, $nesting)
};

Opal.modules["extensions/color"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $klass = Opal.klass, $thrower = Opal.thrower, $def = Opal.def, $rb_divide = Opal.rb_divide, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('eval,rgb_html,/,[]');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Atome');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    
    $def(self, '$rgb_html', function $$rgb_html(string) {try { 
      var js_code = nil;

      
      js_code = "  var col = w3color('" + (string) + "');\n" + "  var rgb_col = col.toRgb();\n" + "  return rgb_col;\n";
      return $$('JS').$eval(js_code);} catch($e) {
        if ($e === Opal.t_eval_return) return $e.$v;
        throw $e;
      }
    });
    return $def(self, '$to_rgb', function $$to_rgb(string) {
      var self = this, rgb_color = nil;

      
      rgb_color = self.$rgb_html(string);
      return (new Map([["red", $rb_divide(rgb_color['$[]']("r"), 255)], ["green", $rb_divide(rgb_color['$[]']("g"), 255)], ["blue", $rb_divide(rgb_color['$[]']("b"), 255)], ["alpha", 1]]));
    });
  })($nesting[0], null, $nesting)
};

Opal.modules["native"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $hash_put = Opal.hash_put, $module = Opal.module, $defs = Opal.defs, $slice = Opal.slice, $truthy = Opal.truthy, $send = Opal.send, $Kernel = Opal.Kernel, $extract_kwargs = Opal.extract_kwargs, $ensure_kwargs = Opal.ensure_kwargs, $hash_get = Opal.hash_get, $range = Opal.range, $to_a = Opal.to_a, $def = Opal.def, $return_ivar = Opal.return_ivar, $alias = Opal.alias, $klass = Opal.klass, $rb_minus = Opal.rb_minus, $return_val = Opal.return_val, $send2 = Opal.send2, $find_super = Opal.find_super, $eqeqeq = Opal.eqeqeq, $rb_ge = Opal.rb_ge, $return_self = Opal.return_self, $gvars = Opal.gvars, self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('try_convert,native?,respond_to?,to_n,raise,inspect,Native,proc,map!,end_with?,define_method,[],convert,call,to_proc,new,each,native_reader,native_writer,extend,warn,include,is_a?,map,Array,to_a,_Array,method_missing,bind,instance_method,[]=,slice,-,length,has_key?,enum_for,===,>=,<<,each_pair,method_defined?,initialize,_initialize,name,native_module');
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Native');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $defs(self, '$is_a?', function $Native_is_a$ques$1(object, klass) {
      var self = this;

      
      try {
        return object instanceof self.$try_convert(klass);
      }
      catch (e) {
        return false;
      }
    
    });
    $defs(self, '$try_convert', function $$try_convert(value, default$) {
      var self = this;

      
      if (default$ == null) default$ = nil;
      
      if (self['$native?'](value)) {
        return value;
      }
      else if (value['$respond_to?']("to_n")) {
        return value.$to_n();
      }
      else {
        return default$;
      }
    ;
    }, -2);
    $defs(self, '$convert', function $$convert(value) {
      var self = this;

      
      if (self['$native?'](value)) {
        return value;
      }
      else if (value['$respond_to?']("to_n")) {
        return value.$to_n();
      }
      else {
        self.$raise($$('ArgumentError'), "" + (value.$inspect()) + " isn't native");
      }
    
    });
    $defs(self, '$call', function $$call(obj, key, $a) {
      var block = $$call.$$p || nil, $post_args, args, self = this;

      $$call.$$p = null;
      
      ;
      $post_args = $slice(arguments, 2);
      args = $post_args;
      
      var prop = obj[key];

      if (prop instanceof Function) {
        var converted = new Array(args.length);

        for (var i = 0, l = args.length; i < l; i++) {
          var item = args[i],
              conv = self.$try_convert(item);

          converted[i] = conv === nil ? item : conv;
        }

        if (block !== nil) {
          converted.push(block);
        }

        return self.$Native(prop.apply(obj, converted));
      }
      else {
        return self.$Native(prop);
      }
    ;
    }, -3);
    $defs(self, '$proc', function $$proc() {
      var block = $$proc.$$p || nil, self = this;

      $$proc.$$p = null;
      
      ;
      if (!$truthy(block)) {
        self.$raise($$('LocalJumpError'), "no block given")
      };
      return $send($Kernel, 'proc', [], function $$2($a){var $post_args, args, self = $$2.$$s == null ? this : $$2.$$s, instance = nil;

        
        $post_args = $slice(arguments);
        args = $post_args;
        $send(args, 'map!', [], function $$3(arg){var self = $$3.$$s == null ? this : $$3.$$s;

          
          if (arg == null) arg = nil;
          return self.$Native(arg);}, {$$s: self});
        instance = self.$Native(this);
        
        // if global is current scope, run the block in the scope it was defined
        if (this === Opal.global) {
          return block.apply(self, args);
        }

        var self_ = block.$$s;
        block.$$s = null;

        try {
          return block.apply(instance, args);
        }
        finally {
          block.$$s = self_;
        }
      ;}, {$$arity: -1, $$s: self});
    });
    (function($base, $parent_nesting) {
      var self = $module($base, 'Helpers');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      
      $def(self, '$alias_native', function $$alias_native(new$, $a, $b) {
        var $post_args, $kwargs, old, as, $yield = $$alias_native.$$p || nil, self = this;

        $$alias_native.$$p = null;
        
        $post_args = $slice(arguments, 1);
        $kwargs = $extract_kwargs($post_args);
        $kwargs = $ensure_kwargs($kwargs);
        
        if ($post_args.length > 0) old = $post_args.shift();if (old == null) old = new$;
        
        as = $hash_get($kwargs, "as");if (as == null) as = nil;
        if ($truthy(old['$end_with?']("="))) {
          return $send(self, 'define_method', [new$], function $$4(value){var self = $$4.$$s == null ? this : $$4.$$s;
            if (self["native"] == null) self["native"] = nil;

            
            if (value == null) value = nil;
            self["native"][old['$[]']($range(0, -2, false))] = $$('Native').$convert(value);
            return value;}, {$$s: self})
        } else if ($truthy(as)) {
          return $send(self, 'define_method', [new$], function $$5($c){var block = $$5.$$p || nil, $post_args, args, self = $$5.$$s == null ? this : $$5.$$s, value = nil;
            if (self["native"] == null) self["native"] = nil;

            $$5.$$p = null;
            
            ;
            $post_args = $slice(arguments);
            args = $post_args;
            value = $send($$('Native'), 'call', [self["native"], old].concat($to_a(args)), block.$to_proc());
            if ($truthy(value)) {
              return as.$new(value.$to_n())
            } else {
              return nil
            };}, {$$arity: -1, $$s: self})
        } else {
          return $send(self, 'define_method', [new$], function $$6($c){var block = $$6.$$p || nil, $post_args, args, self = $$6.$$s == null ? this : $$6.$$s;
            if (self["native"] == null) self["native"] = nil;

            $$6.$$p = null;
            
            ;
            $post_args = $slice(arguments);
            args = $post_args;
            return $send($$('Native'), 'call', [self["native"], old].concat($to_a(args)), block.$to_proc());}, {$$arity: -1, $$s: self})
        };
      }, -2);
      
      $def(self, '$native_reader', function $$native_reader($a) {
        var $post_args, names, self = this;

        
        $post_args = $slice(arguments);
        names = $post_args;
        return $send(names, 'each', [], function $$7(name){var self = $$7.$$s == null ? this : $$7.$$s;

          
          if (name == null) name = nil;
          return $send(self, 'define_method', [name], function $$8(){var self = $$8.$$s == null ? this : $$8.$$s;
            if (self["native"] == null) self["native"] = nil;

            return self.$Native(self["native"][name])}, {$$s: self});}, {$$s: self});
      }, -1);
      
      $def(self, '$native_writer', function $$native_writer($a) {
        var $post_args, names, self = this;

        
        $post_args = $slice(arguments);
        names = $post_args;
        return $send(names, 'each', [], function $$9(name){var self = $$9.$$s == null ? this : $$9.$$s;

          
          if (name == null) name = nil;
          return $send(self, 'define_method', ["" + (name) + "="], function $$10(value){var self = $$10.$$s == null ? this : $$10.$$s;
            if (self["native"] == null) self["native"] = nil;

            
            if (value == null) value = nil;
            return self.$Native(self["native"][name] = value);}, {$$s: self});}, {$$s: self});
      }, -1);
      return $def(self, '$native_accessor', function $$native_accessor($a) {
        var $post_args, names, self = this;

        
        $post_args = $slice(arguments);
        names = $post_args;
        $send(self, 'native_reader', $to_a(names));
        return $send(self, 'native_writer', $to_a(names));
      }, -1);
    })($nesting[0], $nesting);
    (function($base, $parent_nesting) {
      var self = $module($base, 'Wrapper');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      
      $def(self, '$initialize', function $$initialize(native$) {
        var self = this;

        
        if (!$truthy($Kernel['$native?'](native$))) {
          $Kernel.$raise($$('ArgumentError'), "" + (native$.$inspect()) + " isn't native")
        };
        return (self["native"] = native$);
      });
      
      $def(self, '$to_n', $return_ivar("native"));
      return $defs(self, '$included', function $$included(klass) {
        
        return klass.$extend($$('Helpers'))
      });
    })($nesting[0], $nesting);
    return $defs(self, '$included', function $$included(base) {
      var self = this;

      
      self.$warn("Including ::Native is deprecated. Please include Native::Wrapper instead.");
      return base.$include($$('Wrapper'));
    });
  })($nesting[0], $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    
    $def(self, '$native?', function $Kernel_native$ques$11(value) {
      
      return value == null || !value.$$class;
    });
    
    $def(self, '$Native', function $$Native(obj) {
      var $yield = $$Native.$$p || nil, self = this;

      $$Native.$$p = null;
      if ($truthy(obj == null)) {
        return nil
      } else if ($truthy(self['$native?'](obj))) {
        return $$$($$('Native'), 'Object').$new(obj)
      } else if ($truthy(obj['$is_a?']($$('Array')))) {
        return $send(obj, 'map', [], function $$12(o){var self = $$12.$$s == null ? this : $$12.$$s;

          
          if (o == null) o = nil;
          return self.$Native(o);}, {$$s: self})
      } else if ($truthy(obj['$is_a?']($$('Proc')))) {
        return $send(self, 'proc', [], function $$13($a){var block = $$13.$$p || nil, $post_args, args, self = $$13.$$s == null ? this : $$13.$$s;

          $$13.$$p = null;
          
          ;
          $post_args = $slice(arguments);
          args = $post_args;
          return self.$Native($send(obj, 'call', $to_a(args), block.$to_proc()));}, {$$arity: -1, $$s: self})
      } else {
        return obj
      }
    });
    $alias(self, "_Array", "Array");
    return $def(self, '$Array', function $$Array(object, $a) {
      var block = $$Array.$$p || nil, $post_args, args, self = this;

      $$Array.$$p = null;
      
      ;
      $post_args = $slice(arguments, 1);
      args = $post_args;
      if ($truthy(self['$native?'](object))) {
        return $send($$$($$('Native'), 'Array'), 'new', [object].concat($to_a(args)), block.$to_proc()).$to_a()
      };
      return self.$_Array(object);
    }, -2);
  })($nesting[0], $nesting);
  (function($base, $super) {
    var self = $klass($base, $super, 'Object');

    var $proto = self.$$prototype;

    $proto["native"] = nil;
    
    self.$include($$$($$$('Native'), 'Wrapper'));
    
    $def(self, '$==', function $Object_$eq_eq$14(other) {
      var self = this;

      return self["native"] === $$$('Native').$try_convert(other)
    });
    
    $def(self, '$has_key?', function $Object_has_key$ques$15(name) {
      var self = this;

      return Opal.hasOwnProperty.call(self["native"], name)
    });
    
    $def(self, '$each', function $$each($a) {
      var $post_args, args, $yield = $$each.$$p || nil, self = this;

      $$each.$$p = null;
      
      $post_args = $slice(arguments);
      args = $post_args;
      if (($yield !== nil)) {
        
        
        for (var key in self["native"]) {
          Opal.yieldX($yield, [key, self["native"][key]])
        }
      ;
        return self;
      } else {
        return $send(self, 'method_missing', ["each"].concat($to_a(args)))
      };
    }, -1);
    
    $def(self, '$[]', function $Object_$$$16(key) {
      var self = this;

      
      var prop = self["native"][key];

      if (prop instanceof Function) {
        return prop;
      }
      else {
        return $$$('Native').$call(self["native"], key)
      }
    
    });
    
    $def(self, '$[]=', function $Object_$$$eq$17(key, value) {
      var self = this, native$ = nil;

      
      native$ = $$$('Native').$try_convert(value);
      if ($truthy(native$ === nil)) {
        return self["native"][key] = value
      } else {
        return self["native"][key] = native$
      };
    });
    
    $def(self, '$merge!', function $Object_merge$excl$18(other) {
      var self = this;

      
      
      other = $$$('Native').$convert(other);

      for (var prop in other) {
        self["native"][prop] = other[prop];
      }
    ;
      return self;
    });
    
    $def(self, '$respond_to?', function $Object_respond_to$ques$19(name, include_all) {
      var self = this;

      
      if (include_all == null) include_all = false;
      return $Kernel.$instance_method("respond_to?").$bind(self).$call(name, include_all);
    }, -2);
    
    $def(self, '$respond_to_missing?', function $Object_respond_to_missing$ques$20(name, include_all) {
      var self = this;

      
      if (include_all == null) include_all = false;
      return Opal.hasOwnProperty.call(self["native"], name);
    }, -2);
    
    $def(self, '$method_missing', function $$method_missing(mid, $a) {
      var block = $$method_missing.$$p || nil, $post_args, args, $b, self = this;

      $$method_missing.$$p = null;
      
      ;
      $post_args = $slice(arguments, 1);
      args = $post_args;
      
      if (mid.charAt(mid.length - 1) === '=') {
        return ($b = [mid.$slice(0, $rb_minus(mid.$length(), 1)), args['$[]'](0)], $send(self, '[]=', $b), $b[$b.length - 1]);
      }
      else {
        return $send($$$('Native'), 'call', [self["native"], mid].concat($to_a(args)), block.$to_proc());
      }
    ;
    }, -2);
    
    $def(self, '$nil?', $return_val(false));
    
    $def(self, '$is_a?', function $Object_is_a$ques$21(klass) {
      var self = this;

      return Opal.is_a(self, klass);
    });
    
    $def(self, '$instance_of?', function $Object_instance_of$ques$22(klass) {
      var self = this;

      return self.$$class === klass;
    });
    
    $def(self, '$class', function $Object_class$23() {
      var self = this;

      return self.$$class;
    });
    
    $def(self, '$to_a', function $$to_a(options) {
      var block = $$to_a.$$p || nil, self = this;

      $$to_a.$$p = null;
      
      ;
      if (options == null) options = (new Map());
      return $send($$$($$$('Native'), 'Array'), 'new', [self["native"], options], block.$to_proc()).$to_a();
    }, -1);
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      return "#<Native:" + (String(self["native"])) + ">"
    });
    $alias(self, "include?", "has_key?");
    $alias(self, "key?", "has_key?");
    $alias(self, "kind_of?", "is_a?");
    return $alias(self, "member?", "has_key?");
  })($$('Native'), $$('BasicObject'));
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Array');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.named = $proto["native"] = $proto.get = $proto.block = $proto.set = $proto.length = nil;
    
    self.$include($$$($$('Native'), 'Wrapper'));
    self.$include($$('Enumerable'));
    
    $def(self, '$initialize', function $$initialize(native$, options) {
      var block = $$initialize.$$p || nil, self = this, $ret_or_1 = nil;

      $$initialize.$$p = null;
      
      ;
      if (options == null) options = (new Map());
      $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [native$], null);
      self.get = ($truthy(($ret_or_1 = options['$[]']("get"))) ? ($ret_or_1) : (options['$[]']("access")));
      self.named = options['$[]']("named");
      self.set = ($truthy(($ret_or_1 = options['$[]']("set"))) ? ($ret_or_1) : (options['$[]']("access")));
      self.length = ($truthy(($ret_or_1 = options['$[]']("length"))) ? ($ret_or_1) : ("length"));
      self.block = block;
      if ($truthy(self.$length() == null)) {
        return self.$raise($$('ArgumentError'), "no length found on the array-like object")
      } else {
        return nil
      };
    }, -2);
    
    $def(self, '$each', function $$each() {
      var block = $$each.$$p || nil, self = this;

      $$each.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return self.$enum_for("each")
      };
      
      for (var i = 0, length = self.$length(); i < length; i++) {
        Opal.yield1(block, self['$[]'](i));
      }
    ;
      return self;
    });
    
    $def(self, '$[]', function $Array_$$$24(index) {
      var self = this, result = nil, $ret_or_1 = nil;

      
      result = (($eqeqeq($$('String'), ($ret_or_1 = index)) || ($eqeqeq($$('Symbol'), $ret_or_1))) ? (($truthy(self.named) ? (self["native"][self.named](index)) : (self["native"][index]))) : ($eqeqeq($$('Integer'), $ret_or_1) ? (($truthy(self.get) ? (self["native"][self.get](index)) : (self["native"][index]))) : (nil)));
      if ($truthy(result)) {
        if ($truthy(self.block)) {
          return self.block.$call(result)
        } else {
          return self.$Native(result)
        }
      } else {
        return nil
      };
    });
    
    $def(self, '$[]=', function $Array_$$$eq$25(index, value) {
      var self = this;

      if ($truthy(self.set)) {
        return self["native"][self.set](index, $$('Native').$convert(value))
      } else {
        return self["native"][index] = $$('Native').$convert(value)
      }
    });
    
    $def(self, '$last', function $$last(count) {
      var self = this, index = nil, result = nil;

      
      if (count == null) count = nil;
      if ($truthy(count)) {
        
        index = $rb_minus(self.$length(), 1);
        result = [];
        while ($truthy($rb_ge(index, 0))) {
        
          result['$<<'](self['$[]'](index));
          index = $rb_minus(index, 1);
        };
        return result;
      } else {
        return self['$[]']($rb_minus(self.$length(), 1))
      };
    }, -1);
    
    $def(self, '$length', function $$length() {
      var self = this;

      return self["native"][self.length]
    });
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      return self.$to_a().$inspect()
    });
    return $alias(self, "to_ary", "to_a");
  })($$('Native'), null, $nesting);
  (function($base, $super) {
    var self = $klass($base, $super, 'Numeric');

    
    return $def(self, '$to_n', function $$to_n() {
      var self = this;

      return self.valueOf();
    })
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'Proc');

    
    return $def(self, '$to_n', $return_self)
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'String');

    
    return $def(self, '$to_n', function $$to_n() {
      var self = this;

      return self.valueOf();
    })
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'Regexp');

    
    return $def(self, '$to_n', function $$to_n() {
      var self = this;

      return self.valueOf();
    })
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'MatchData');

    
    return $def(self, '$to_n', $return_ivar("matches"))
  })($nesting[0], null);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Struct');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$to_n', function $$to_n() {
      var self = this, result = nil;

      
      result = {};
      $send(self, 'each_pair', [], function $$26(name, value){
        
        if (name == null) name = nil;
        if (value == null) value = nil;
        return result[name] = $$('Native').$try_convert(value, value);});
      return result;
    })
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Array');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$to_n', function $$to_n() {
      var self = this;

      
      var result = [];

      for (var i = 0, length = self.length; i < length; i++) {
        var obj = self[i];

        result.push($$('Native').$try_convert(obj, obj));
      }

      return result;
    
    })
  })($nesting[0], null, $nesting);
  (function($base, $super) {
    var self = $klass($base, $super, 'Boolean');

    
    return $def(self, '$to_n', function $$to_n() {
      var self = this;

      return self.valueOf();
    })
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'Time');

    
    return $def(self, '$to_n', $return_self)
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'NilClass');

    
    return $def(self, '$to_n', function $$to_n() {
      
      return null;
    })
  })($nesting[0], null);
  if (!$truthy($$('Hash')['$method_defined?']("_initialize"))) {
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Hash');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      $alias(self, "_initialize", "initialize");
      
      function $hash_convert_and_put_value(hash, key, value) {
        if (value &&
          (value.constructor === undefined ||
            value.constructor === Object ||
            value instanceof Map)) {
         $hash_put(hash, key, $$('Hash').$new(value));
       } else if (value && value.$$is_array) {
         value = value.map(function(item) {
           if (item &&
              (item.constructor === undefined ||
               item.constructor === Object ||
               value instanceof Map)) {
             return $$('Hash').$new(item);
           }
           return self.$Native(item);
         });
         $hash_put(hash, key, value)
       } else {
         $hash_put(hash, key, self.$Native(value));
       }
      }
    ;
      
      $def(self, '$initialize', function $$initialize(defaults) {
        var block = $$initialize.$$p || nil, self = this;

        $$initialize.$$p = null;
        
        ;
        ;
        
        if (defaults != null) {
          if (defaults.constructor === undefined ||
              defaults.constructor === Object) {
            var key, value;

            for (key in defaults) {
              value = defaults[key];
              $hash_convert_and_put_value(self, key, value);
            }

            return self;
          } else if (defaults instanceof Map) {
            Opal.hash_each(defaults, false, function(key, value) {
              $hash_convert_and_put_value(self, key, value);
              return [false, false];
            });
          }
        }

        return $send(self, '_initialize', [defaults], block.$to_proc());
      ;
      }, -1);
      return $def(self, '$to_n', function $$to_n() {
        var self = this;

        
        var result = {};

        Opal.hash_each(self, false, function(key, value) {
          result[$$('Native').$try_convert(key, key)] = $$('Native').$try_convert(value, value);
          return [false, false];
        });

        return result;
      
      });
    })($nesting[0], null, $nesting)
  };
  (function($base, $super) {
    var self = $klass($base, $super, 'Module');

    
    return $def(self, '$native_module', function $$native_module() {
      var self = this;

      return Opal.global[self.$name()] = self
    })
  })($nesting[0], null);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Class');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    
    $def(self, '$native_alias', function $$native_alias(new_jsid, existing_mid) {
      var self = this;

      
      var aliased = self.prototype[Opal.jsid(existing_mid)];
      if (!aliased) {
        self.$raise($$('NameError').$new("undefined method `" + (existing_mid) + "' for class `" + (self.$inspect()) + "'", existing_mid));
      }
      self.prototype[new_jsid] = aliased;
    
    });
    return $def(self, '$native_class', function $$native_class() {
      var self = this;

      
      self.$native_module();
      return self["new"] = self.$new;;
    });
  })($nesting[0], null, $nesting);
  return ($gvars.$ = ($gvars.global = self.$Native(Opal.global)));
};

Opal.modules["promise"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $klass = Opal.klass, $defs = Opal.defs, $slice = Opal.slice, $def = Opal.def, $eqeqeq = Opal.eqeqeq, $truthy = Opal.truthy, $return_ivar = Opal.return_ivar, $not = Opal.not, $send = Opal.send, $to_a = Opal.to_a, $rb_plus = Opal.rb_plus, $alias = Opal.alias, $send2 = Opal.send2, $find_super = Opal.find_super, $rb_le = Opal.rb_le, $rb_minus = Opal.rb_minus, $const_set = Opal.const_set, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil;

  Opal.add_stubs('resolve,new,reject,attr_reader,===,value,key?,keys,!=,==,<<,>>,exception?,[],resolved?,rejected?,!,error,include?,action,realized?,raise,^,call,resolve!,exception!,any?,each,reject!,there_can_be_only_one!,then,to_proc,fail,always,trace,class,object_id,+,inspect,rescue,to_v2,fail!,then!,always!,itself,nil?,prev,act?,push,concat,it,proc,reverse,pop,<=,length,shift,-,wait,map,reduce,try,tap,all?,find,collect,inject');
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Promise');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.value = $proto.action = $proto.realized = $proto.next = $proto.delayed = $proto.error = $proto.prev = nil;
    
    $defs(self, '$value', function $$value(value) {
      var self = this;

      return self.$new().$resolve(value)
    });
    $defs(self, '$error', function $$error(value) {
      var self = this;

      return self.$new().$reject(value)
    });
    $defs(self, '$when', function $$when($a) {
      var $post_args, promises;

      
      $post_args = $slice(arguments);
      promises = $post_args;
      return $$('When').$new(promises);
    }, -1);
    self.$attr_reader("error", "prev", "next");
    
    $def(self, '$initialize', function $$initialize(action) {
      var self = this;

      
      if (action == null) action = (new Map());
      self.action = action;
      self.realized = false;
      self.exception = false;
      self.value = nil;
      self.error = nil;
      self.delayed = false;
      self.prev = nil;
      return (self.next = []);
    }, -1);
    
    $def(self, '$value', function $$value() {
      var self = this;

      if ($eqeqeq($$('Promise'), self.value)) {
        return self.value.$value()
      } else {
        return self.value
      }
    });
    
    $def(self, '$act?', function $Promise_act$ques$1() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.action['$key?']("success")))) {
        return $ret_or_1
      } else {
        return self.action['$key?']("always")
      }
    });
    
    $def(self, '$action', function $$action() {
      var self = this;

      return self.action.$keys()
    });
    
    $def(self, '$exception?', $return_ivar("exception"));
    
    $def(self, '$realized?', function $Promise_realized$ques$2() {
      var self = this;

      return self.realized['$!='](false)
    });
    
    $def(self, '$resolved?', function $Promise_resolved$ques$3() {
      var self = this;

      return self.realized['$==']("resolve")
    });
    
    $def(self, '$rejected?', function $Promise_rejected$ques$4() {
      var self = this;

      return self.realized['$==']("reject")
    });
    
    $def(self, '$^', function $Promise_$$5(promise) {
      var self = this;

      
      promise['$<<'](self);
      self['$>>'](promise);
      return promise;
    });
    
    $def(self, '$<<', function $Promise_$lt$lt$6(promise) {
      var self = this;

      
      self.prev = promise;
      return self;
    });
    
    $def(self, '$>>', function $Promise_$gt$gt$7(promise) {
      var self = this;

      
      self.next['$<<'](promise);
      if ($truthy(self['$exception?']())) {
        promise.$reject(self.delayed['$[]'](0))
      } else if ($truthy(self['$resolved?']())) {
        promise.$resolve(($truthy(self.delayed) ? (self.delayed['$[]'](0)) : (self.$value())))
      } else if ($truthy(self['$rejected?']())) {
        if (($not(self.action['$key?']("failure")) || ($eqeqeq($$('Promise'), ($truthy(self.delayed) ? (self.delayed['$[]'](0)) : (self.error)))))) {
          promise.$reject(($truthy(self.delayed) ? (self.delayed['$[]'](0)) : (self.$error())))
        } else if ($truthy(promise.$action()['$include?']("always"))) {
          promise.$reject(($truthy(self.delayed) ? (self.delayed['$[]'](0)) : (self.$error())))
        }
      };
      return self;
    });
    
    $def(self, '$resolve', function $$resolve(value) {
      var self = this, block = nil, $ret_or_1 = nil, e = nil;

      
      if (value == null) value = nil;
      if ($truthy(self['$realized?']())) {
        self.$raise($$('ArgumentError'), "the promise has already been realized")
      };
      if ($eqeqeq($$('Promise'), value)) {
        return value['$<<'](self.prev)['$^'](self)
      };
      
      try {
        
        block = ($truthy(($ret_or_1 = self.action['$[]']("success"))) ? ($ret_or_1) : (self.action['$[]']("always")));
        if ($truthy(block)) {
          value = block.$call(value)
        };
        self['$resolve!'](value);
      } catch ($err) {
        if (Opal.rescue($err, [$$('Exception')])) {(e = $err)
          try {
            self['$exception!'](e)
          } finally { Opal.pop_exception($err); }
        } else { throw $err; }
      };;
      return self;
    }, -1);
    
    $def(self, '$resolve!', function $Promise_resolve$excl$8(value) {
      var self = this;

      
      self.realized = "resolve";
      self.value = value;
      if ($truthy(self.next['$any?']())) {
        return $send(self.next, 'each', [], function $$9(p){
          
          if (p == null) p = nil;
          return p.$resolve(value);})
      } else {
        return (self.delayed = [value])
      };
    });
    
    $def(self, '$reject', function $$reject(value) {
      var self = this, block = nil, $ret_or_1 = nil, e = nil;

      
      if (value == null) value = nil;
      if ($truthy(self['$realized?']())) {
        self.$raise($$('ArgumentError'), "the promise has already been realized")
      };
      if ($eqeqeq($$('Promise'), value)) {
        return value['$<<'](self.prev)['$^'](self)
      };
      
      try {
        
        block = ($truthy(($ret_or_1 = self.action['$[]']("failure"))) ? ($ret_or_1) : (self.action['$[]']("always")));
        if ($truthy(block)) {
          value = block.$call(value)
        };
        if ($truthy(self.action['$key?']("always"))) {
          self['$resolve!'](value)
        } else {
          self['$reject!'](value)
        };
      } catch ($err) {
        if (Opal.rescue($err, [$$('Exception')])) {(e = $err)
          try {
            self['$exception!'](e)
          } finally { Opal.pop_exception($err); }
        } else { throw $err; }
      };;
      return self;
    }, -1);
    
    $def(self, '$reject!', function $Promise_reject$excl$10(value) {
      var self = this;

      
      self.realized = "reject";
      self.error = value;
      if ($truthy(self.next['$any?']())) {
        return $send(self.next, 'each', [], function $$11(p){
          
          if (p == null) p = nil;
          return p.$reject(value);})
      } else {
        return (self.delayed = [value])
      };
    });
    
    $def(self, '$exception!', function $Promise_exception$excl$12(error) {
      var self = this;

      
      self.exception = true;
      return self['$reject!'](error);
    });
    
    $def(self, '$then', function $$then() {
      var block = $$then.$$p || nil, self = this;

      $$then.$$p = null;
      
      ;
      return self['$^']($$('Promise').$new((new Map([["success", block]]))));
    });
    
    $def(self, '$then!', function $Promise_then$excl$13() {
      var block = $Promise_then$excl$13.$$p || nil, self = this;

      $Promise_then$excl$13.$$p = null;
      
      ;
      self['$there_can_be_only_one!']();
      return $send(self, 'then', [], block.$to_proc());
    });
    
    $def(self, '$fail', function $$fail() {
      var block = $$fail.$$p || nil, self = this;

      $$fail.$$p = null;
      
      ;
      return self['$^']($$('Promise').$new((new Map([["failure", block]]))));
    });
    
    $def(self, '$fail!', function $Promise_fail$excl$14() {
      var block = $Promise_fail$excl$14.$$p || nil, self = this;

      $Promise_fail$excl$14.$$p = null;
      
      ;
      self['$there_can_be_only_one!']();
      return $send(self, 'fail', [], block.$to_proc());
    });
    
    $def(self, '$always', function $$always() {
      var block = $$always.$$p || nil, self = this;

      $$always.$$p = null;
      
      ;
      return self['$^']($$('Promise').$new((new Map([["always", block]]))));
    });
    
    $def(self, '$always!', function $Promise_always$excl$15() {
      var block = $Promise_always$excl$15.$$p || nil, self = this;

      $Promise_always$excl$15.$$p = null;
      
      ;
      self['$there_can_be_only_one!']();
      return $send(self, 'always', [], block.$to_proc());
    });
    
    $def(self, '$trace', function $$trace(depth) {
      var block = $$trace.$$p || nil, self = this;

      $$trace.$$p = null;
      
      ;
      if (depth == null) depth = nil;
      return self['$^']($$('Trace').$new(depth, block));
    }, -1);
    
    $def(self, '$trace!', function $Promise_trace$excl$16($a) {
      var block = $Promise_trace$excl$16.$$p || nil, $post_args, args, self = this;

      $Promise_trace$excl$16.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      self['$there_can_be_only_one!']();
      return $send(self, 'trace', $to_a(args), block.$to_proc());
    }, -1);
    
    $def(self, '$there_can_be_only_one!', function $Promise_there_can_be_only_one$excl$17() {
      var self = this;

      if ($truthy(self.next['$any?']())) {
        return self.$raise($$('ArgumentError'), "a promise has already been chained")
      } else {
        return nil
      }
    });
    
    $def(self, '$inspect', function $$inspect() {
      var self = this, result = nil, $ret_or_1 = nil;

      
      result = "#<" + (self.$class()) + "(" + (self.$object_id()) + ")";
      if ($truthy(self.next['$any?']())) {
        result = $rb_plus(result, " >> " + (self.next.$inspect()))
      };
      result = $rb_plus(result, ($truthy(self['$realized?']()) ? (": " + (($truthy(($ret_or_1 = self.value)) ? ($ret_or_1) : (self.error)).$inspect()) + ">") : (">")));
      return result;
    });
    
    $def(self, '$to_v2', function $$to_v2() {
      var self = this, v2 = nil;

      
      v2 = $$('PromiseV2').$new();
      $send($send(self, 'then', [], function $$18(i){
        
        if (i == null) i = nil;
        return v2.$resolve(i);}), 'rescue', [], function $$19(i){
        
        if (i == null) i = nil;
        return v2.$reject(i);});
      return v2;
    });
    $alias(self, "await", "to_v2");
    $alias(self, "catch", "fail");
    $alias(self, "catch!", "fail!");
    $alias(self, "do", "then");
    $alias(self, "do!", "then!");
    $alias(self, "ensure", "always");
    $alias(self, "ensure!", "always!");
    $alias(self, "finally", "always");
    $alias(self, "finally!", "always!");
    $alias(self, "rescue", "fail");
    $alias(self, "rescue!", "fail!");
    $alias(self, "to_n", "to_v2");
    $alias(self, "to_v1", "itself");
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Trace');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      $defs(self, '$it', function $$it(promise) {
        var self = this, current = nil, prev = nil;

        
        current = [];
        if (($truthy(promise['$act?']()) || ($truthy(promise.$prev()['$nil?']())))) {
          current.$push(promise.$value())
        };
        prev = promise.$prev();
        if ($truthy(prev)) {
          return current.$concat(self.$it(prev))
        } else {
          return current
        };
      });
      return $def(self, '$initialize', function $$initialize(depth, block) {
        var $yield = $$initialize.$$p || nil, self = this;

        $$initialize.$$p = null;
        
        self.depth = depth;
        return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [(new Map([["success", $send(self, 'proc', [], function $$20(){var self = $$20.$$s == null ? this : $$20.$$s, trace = nil;

          
          trace = $$('Trace').$it(self).$reverse();
          trace.$pop();
          if (($truthy(depth) && ($truthy($rb_le(depth, trace.$length()))))) {
            trace.$shift($rb_minus(trace.$length(), depth))
          };
          return $send(block, 'call', $to_a(trace));}, {$$s: self})]]))], null);
      });
    })($nesting[0], self, $nesting);
    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'When');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.wait = nil;
      
      
      $def(self, '$initialize', function $$initialize(promises) {
        var $yield = $$initialize.$$p || nil, self = this;

        $$initialize.$$p = null;
        
        if (promises == null) promises = [];
        $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [], null);
        self.wait = [];
        return $send(promises, 'each', [], function $$21(promise){var self = $$21.$$s == null ? this : $$21.$$s;

          
          if (promise == null) promise = nil;
          return self.$wait(promise);}, {$$s: self});
      }, -1);
      
      $def(self, '$each', function $$each() {
        var block = $$each.$$p || nil, self = this;

        $$each.$$p = null;
        
        ;
        if (!$truthy(block)) {
          self.$raise($$('ArgumentError'), "no block given")
        };
        return $send(self, 'then', [], function $$22(values){
          
          if (values == null) values = nil;
          return $send(values, 'each', [], block.$to_proc());});
      });
      
      $def(self, '$collect', function $$collect() {
        var block = $$collect.$$p || nil, self = this;

        $$collect.$$p = null;
        
        ;
        if (!$truthy(block)) {
          self.$raise($$('ArgumentError'), "no block given")
        };
        return $send(self, 'then', [], function $$23(values){
          
          if (values == null) values = nil;
          return $$('When').$new($send(values, 'map', [], block.$to_proc()));});
      });
      
      $def(self, '$inject', function $$inject($a) {
        var block = $$inject.$$p || nil, $post_args, args, self = this;

        $$inject.$$p = null;
        
        ;
        $post_args = $slice(arguments);
        args = $post_args;
        return $send(self, 'then', [], function $$24(values){
          
          if (values == null) values = nil;
          return $send(values, 'reduce', $to_a(args), block.$to_proc());});
      }, -1);
      
      $def(self, '$wait', function $$wait(promise) {
        var self = this;

        
        if (!$eqeqeq($$('Promise'), promise)) {
          promise = $$('Promise').$value(promise)
        };
        if ($truthy(promise['$act?']())) {
          promise = promise.$then()
        };
        self.wait['$<<'](promise);
        $send(promise, 'always', [], function $$25(){var self = $$25.$$s == null ? this : $$25.$$s;
          if (self.next == null) self.next = nil;

          if ($truthy(self.next['$any?']())) {
            return self.$try()
          } else {
            return nil
          }}, {$$s: self});
        return self;
      });
      
      $def(self, '$>>', function $When_$gt$gt$26($a) {
        var $post_args, $fwd_rest, $yield = $When_$gt$gt$26.$$p || nil, self = this;

        $When_$gt$gt$26.$$p = null;
        
        $post_args = $slice(arguments);
        $fwd_rest = $post_args;
        return $send($send2(self, $find_super(self, '>>', $When_$gt$gt$26, false, true), '>>', $to_a($fwd_rest), $yield), 'tap', [], function $$27(){var self = $$27.$$s == null ? this : $$27.$$s;

          return self.$try()}, {$$s: self});
      }, -1);
      
      $def(self, '$try', function $When_try$28() {
        var self = this, promise = nil;

        if ($truthy($send(self.wait, 'all?', [], "realized?".$to_proc()))) {
          
          promise = $send(self.wait, 'find', [], "rejected?".$to_proc());
          if ($truthy(promise)) {
            return self.$reject(promise.$error())
          } else {
            return self.$resolve($send(self.wait, 'map', [], "value".$to_proc()))
          };
        } else {
          return nil
        }
      });
      $alias(self, "map", "collect");
      $alias(self, "reduce", "inject");
      return $alias(self, "and", "wait");
    })($nesting[0], self, $nesting);
  })($nesting[0], null, $nesting);
  return $const_set($nesting[0], 'PromiseV1', $$('Promise'));
};

Opal.queue(function(Opal) {/* Generated by Opal 1.8.2 */
  var self = Opal.top, nil = Opal.nil;

  Opal.add_stubs('require');
  
  self.$require("extensions/object");
  self.$require("extensions/js");
  self.$require("extensions/geolocation");
  self.$require("extensions/ping");
  self.$require("extensions/sha");
  self.$require("extensions/color");
  self.$require("native");
  return self.$require("promise");
});
